/**
 * Alternative version that takes vectors [x] and [y] instead of
 * [values] as input and returns intervals that contain local minima
 * and local maxima. [x] elements can be of any type.
 *
 * @author Balint Morvai <balint@morvai.de>
 * @license http://en.wikipedia.org/wiki/MIT_License MIT License
 * @param x
 * @param y
 * @param eps
 * @returns {minlist: Array, maxlist: Array}
 */

/**
 * Calculate approximate derivative of a vector Y, assuming
 * that Y=f(X) with given vector X.
 *
 * Takes objects or arrays X and Y with m numbers and returns
 * an array dY with m-1 numbers that constitutes the approximate
 * derivative:
 * dY = [(Y(2)-Y(1))/(X(2)-X(1))  (Y(3)-Y(2)/(X(3)-X(2)) ...
 *       (Y(m)-Y(m-1))/((X(m)-X(m-1))]
 *
 * If as second parameter a number n is given, the returned array
 * dY will be the n-th differential, thus above step applied n-times.
 *
 * @author Balint Morvai <balint@morvai.de>
 * @license http://en.wikipedia.org/wiki/MIT_License MIT License
 * @param x
 * @param y
 * @param n
 * @returns Array
 */

/**
 * Calculate approximate integral of a vector, assuming
 * that Y=f(X) with given vector X.
 *
 * Takes an object or array Y with m numbers and returns an array
 * X with m numbers that constitutes the integral:
 * [ ...
 *  -Y(m)*(X(m)-X(m-1)-Y(m-1)*(X(m)-X(m-1)-Y(m-2)*(X(m-1)-X(m-2)-Y(m-3)*(X(m-2)-X(m-3)
 *  -Y(m)*(X(m)-X(m-1)-Y(m-1)*(X(m)-X(m-1)-Y(m-2)*(X(m-1)-X(m-2)
 *  -Y(m)*(X(m)-X(m-1)-Y(m-1)*(X(m)-X(m-1)
 *  -Y(m)*(X(m)-X(m-1))
 * ]
 *
 * If as second parameter a number n is given, the returned array
 * X will be the n-th integral, thus above step applied n-times.
 *
 * NOTE: the integral cannot determine the original set of values
 * before "diff" was applied, thus "integral(diff(values)) != values"
 * due to the nature of integration and differentiation. However the
 * shape of the result will be the same, the curve will only be
 * shifted by a constant value. ("translation")
 *
 * @author Balint Morvai <balint@morvai.de>
 * @license http://en.wikipedia.org/wiki/MIT_License MIT License
 * @param x
 * @param y
 * @param n
 * @returns Array
 */

/**
 * Calculate differences of a vector.
 *
 * Takes an object or array Y with m numbers and returns an array
 * dY with m-1 numbers that constitutes the differences:
 * dY = [Y(2)-Y(1) Y(3)-Y(2) ... Y(m)-Y(m-1)]
 * If Y are function values f(1), f(2), ... with a step size of 1,
 * then dY constitutes the approximate derivative of f. For a different
 * step size use diffXY.
 * NOTE: For a step size other than 1, the differences do NOT constitute
 * the approximate derivative and thus in those cases use diffXY if you
 * want to get the derivative.
 *
 * If as second parameter a number n is given, the returned array
 * dY will be the n-th differential, thus above step applied n-times.
 *
 * @author Balint Morvai <balint@morvai.de>
 * @license http://en.wikipedia.org/wiki/MIT_License MIT License
 * @param values
 * @param n
 * @returns Array
 */

/**
 * Calculate reverse differences of a vector.
 *
 * Takes an object or array Y with m numbers and returns an array
 * IY with m numbers that constitutes the reverse differences:
 * [ ... -Y(m)-Y(m-1)-Y(m-2)  -Y(m)-Y(m-1)  -Y(m)]
 * If Y are function values f(1), f(2), ... with a step size of 1,
 * then IY constitutes the approximate integral of f. For a different
 * step size use integralXY.
 *
 * If as second parameter a number n is given, the returned array
 * Y will be the n-th integral, thus above step applied n-times.
 *
 * NOTE: the integral cannot determine the original set of values
 * before "diff" was applied, thus "integral(diff(values)) != values"
 * due to the nature of integration and differentiation. However the
 * shape of the result will be the same, the curve will only be
 * shifted by a constant value. ("translation")
 *
 * @author Balint Morvai <balint@morvai.de>
 * @license http://en.wikipedia.org/wiki/MIT_License MIT License
 * @param values
 * @param n
 * @returns Array
 */

/**
 * Find local maxima and minima in a list of values.
 *
 * Javascript implementation of:
 * "A Linear-Time Algorithm That Locates Local Extrema
 * of a Function of One Variable From Interval Measurement
 * Results" - Karen Villaverde, Vladik Kreinovich
 * (Interval Computations 01/1993; 1993(4))
 *
 * Takes an object or array with numbers and returns an object
 * with two lists of indices: 'minlist' with indices of values
 * that are local minima and 'maxlist' with indices of values that
 * are local maxima. Indices can be of any type.
 * Takes numbers as first parameter and an accuracy > 0 (epsilon)
 * as second parameter. The accuracy has to be chosen depending
 * on the fluctuations in the data: smaller values mean greater
 * reliability in finding extrema but also greater chance of
 * confusing noise with a local minimum or maximum.
 *
 * @author Balint Morvai <balint@morvai.de>
 * @license http://en.wikipedia.org/wiki/MIT_License MIT License
 * @param values
 * @param eps
 * @returns {minlist: Array, maxlist: Array}
 */
